<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Huff & Puff</title>
<style>
  :root { --bg:#FFEDD5; --panel:#FFF7ED; --accent:#FF6B6B; --good:#36D399; --bad:#F43F5E; }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  #gameCanvas{display:block;background:linear-gradient(180deg,#FFE4B5,#FFD4A3);width:100%;height:100vh;}
  .ui { position:absolute; left:0; right:0; top:0; pointer-events:none; }
  .topbar { display:flex; justify-content:space-between; align-items:center; padding:14px; pointer-events:auto; }
  .btn { background:var(--accent); color:white; border-radius:12px; padding:8px 12px; font-weight:700; box-shadow:0 6px 0 rgba(0,0,0,0.08);}
  #playBtn { font-size:22px; padding:16px 26px; border-radius:16px; }
  #moodBarWrap { width:70%; max-width:420px; height:28px; background:rgba(0,0,0,0.06); border-radius:14px; overflow:hidden; }
  #moodBar { height:100%; width:30%; background:linear-gradient(90deg,var(--good),#FFD166); transition:width 0.25s linear; }
  #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  #panel { pointer-events:auto; background:var(--panel); padding:20px; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,0.12); text-align:center; width:90%; max-width:420px;}
  .hidden{ display:none; }
  #miniHud { position:absolute; right:12px; top:84px; pointer-events:none; }
  .power { display:block; margin:8px 0; background:#fff; border-radius:10px; padding:8px; box-shadow:0 4px 10px rgba(0,0,0,0.06); pointer-events:auto;}
  .small { font-size:13px; color:#333; }
  #footer { position:absolute; left:0; right:0; bottom:16px; text-align:center; font-size:13px; color:#333; pointer-events:none;}
  /* small responsive tweaks */
  @media (max-width:420px){ #moodBarWrap{ width:56%; } .btn{ padding:8px 10px; } }
</style>
</head>
<body>
<canvas id="gameCanvas" width="1080" height="1920"></canvas>

<div class="ui">
  <div class="topbar">
    <div id="moodBarWrap">
      <div id="moodBar"></div>
    </div>

    <div style="pointer-events:auto;">
      <button id="playBtn" class="btn">PLAY</button>
    </div>
  </div>

  <div id="overlay">
    <div id="panel">
      <h1 id="title">HUFF &amp; PUFF</h1>
      <p id="subtitle">She’s 12. She’s got attitude. Calm her before she wrecks the world.</p>
      <div style="margin-top:12px;">
        <button id="startBtn" class="btn" style="font-size:18px;padding:12px 20px;">Start</button>
        <button id="howBtn" class="btn" style="background:#F59E0B;margin-left:8px;padding:10px 14px;">How to play</button>
      </div>
      <div id="how" class="hidden" style="text-align:left;margin-top:12px;">
        <ul style="padding-left:18px;margin:6px 0;">
          <li>Tap to deflect drama bubbles.</li>
          <li>Drag snacks to Huff to calm her.</li>
          <li>Tap the cat quickly to pet it.</li>
          <li>Be fast — mood rises over time and during tantrums.</li>
        </ul>
      </div>
    </div>
  </div>

  <div id="miniHud" class="hidden">
    <div id="powerUpList"></div>
  </div>

  <div id="footer">Tap or drag — one-hand friendly. Built with HTML5 canvas.</div>
</div>

<script>
/*
  Huff & Puff - simple HTML5 game
  - Single-file for easy testing
  - Touch + mouse controls
*/

// Canvas init
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

function resizeCanvas() {
  // keep internal resolution high but scale visually
  const ratio = window.devicePixelRatio || 1;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  canvas.style.width = vw + 'px';
  canvas.style.height = vh + 'px';
  canvas.width = Math.max(720, Math.floor(vw * ratio));
  canvas.height = Math.max(1280, Math.floor(vh * ratio));
  W = canvas.width; H = canvas.height;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game states
const STATE = { MENU:0, PLAY:1, MINIGAME:2, GAMEOVER:3 };
let state = STATE.MENU;

// UI refs
const overlay = document.getElementById('overlay');
const panel = document.getElementById('panel');
const startBtn = document.getElementById('startBtn');
const howBtn = document.getElementById('howBtn');
const howBox = document.getElementById('how');
const playBtn = document.getElementById('playBtn');
const moodBar = document.getElementById('moodBar');
const miniHud = document.getElementById('miniHud');
const powerUpList = document.getElementById('powerUpList');

startBtn.onclick = () => startGame();
playBtn.onclick = () => {
  if(state === STATE.MENU) startGame(); else resetToMenu();
};
howBtn.onclick = () => howBox.classList.toggle('hidden');

function resetToMenu(){
  state = STATE.MENU;
  overlay.style.display = 'flex';
  panel.querySelector('#title').innerText = 'HUFF & PUFF';
  playBtn.innerText = 'PLAY';
}

// Visual assets placeholders (simple shapes). Replace with images as needed.
function drawGirl(x,y,size,ang=0,madRatio=0.6){
  // body
  ctx.save();
  ctx.translate(x,y);
  if(ang) ctx.rotate(ang);
  // legs
  ctx.fillStyle='#2F855A';
  ctx.fillRect(-size*0.22, size*0.32, size*0.18, size*0.28);
  ctx.fillRect(size*0.04, size*0.32, size*0.18, size*0.28);
  // shirt
  ctx.fillStyle = '#6B46C1';
  ctx.fillRect(-size*0.33, -size*0.05, size*0.66, size*0.32);
  // head
  ctx.beginPath();
  ctx.fillStyle = '#F9C2B6';
  ctx.ellipse(0, -size*0.25, size*0.28, size*0.32, 0, 0, Math.PI*2);
  ctx.fill();
  // eyes/eyebrows depend on mood
  ctx.fillStyle = '#111';
  const browShift = madRatio*8;
  ctx.fillRect(-size*0.22, -size*0.36 - browShift/6, size*0.26, size*0.048);
  ctx.fillRect(size*-0.02, -size*0.36 - browShift/6, size*0.26, size*0.048);
  // pupils
  ctx.beginPath(); ctx.fillStyle='#fff'; ctx.ellipse(-size*0.11, -size*0.21, size*0.06, size*0.08, 0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle='#fff'; ctx.ellipse(size*0.13, -size*0.21, size*0.06, size*0.08, 0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle='#111'; ctx.ellipse(-size*0.11, -size*0.21, size*0.03, size*0.04, 0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle='#111'; ctx.ellipse(size*0.13, -size*0.21, size*0.03, size*0.04, 0,0,Math.PI*2); ctx.fill();
  // mouth
  ctx.fillStyle = '#5A2C2C';
  const mouthY = -size*0.1 + madRatio*size*0.05;
  ctx.fillRect(-size*0.1, mouthY, size*0.2, size*0.04);
  // tiny puff
  if(madRatio>0.4){
    ctx.fillStyle = 'rgba(240,240,240,0.9)';
    ctx.beginPath(); ctx.ellipse(size*0.46, -size*0.28, size*0.06*madRatio, size*0.05*madRatio, 0,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

// game variables
let mood = 0.18;            // 0 = calm, 1 = explode
let moodIncreaseRate = 0.002; // per frame baseline
let lastTime = 0;
let rng = (a=1)=>Math.random()*a;
let activeMini = null;
let miniTimer = 0;
let powerUps = { snacks:0, wifi:0 };
let score = 0;
let highScore = 0;
let spawnCooldown = 0;

// helper for touch/mouse
let pointer = { x:0, y:0, down:false, id:null };
function setPointer(e,down=false){
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;
  if(e.touches && e.touches[0]) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
  else if (e.changedTouches && e.changedTouches[0]) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
  else { clientX = e.clientX; clientY = e.clientY; }
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  pointer.x = (clientX - rect.left) * scaleX;
  pointer.y = (clientY - rect.top) * scaleY;
  pointer.down = down;
}

// input listeners
canvas.addEventListener('mousedown', (e)=>{ setPointer(e,true); handlePointerDown(pointer); });
canvas.addEventListener('mouseup', (e)=>{ setPointer(e,false); handlePointerUp(pointer); });
canvas.addEventListener('mousemove', (e)=>{ setPointer(e,false); handlePointerMove(pointer); });

canvas.addEventListener('touchstart', (e)=>{ setPointer(e,true); handlePointerDown(pointer); e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend', (e)=>{ setPointer(e,false); handlePointerUp(pointer); e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchmove', (e)=>{ setPointer(e,true); handlePointerMove(pointer); e.preventDefault(); }, {passive:false});

// core game loop
function startGame(){
  overlay.style.display = 'none';
  state = STATE.PLAY;
  mood = 0.18;
  moodIncreaseRate = 0.0025;
  powerUps = { snacks:0, wifi:0 };
  score = 0;
  spawnCooldown = 0;
  activeMini = null;
  miniTimer = 0;
  playBtn.innerText = 'MENU';
  miniHud.classList.remove('hidden');
  renderPowerUps();
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function loop(ts){
  const dt = Math.min(40, ts - lastTime) / 16.67; // normalize roughly to frames
  lastTime = ts;
  update(dt);
  render();
  if(state === STATE.PLAY || state === STATE.MINIGAME) requestAnimationFrame(loop);
}

function update(dt){
  if(state === STATE.PLAY){
    // baseline mood increase and risk events
    mood += moodIncreaseRate * dt;
    // spawn mini-games occasionally, spawnCooldown prevents spam
    spawnCooldown -= dt;
    if(spawnCooldown <= 0 && Math.random() < 0.02 * dt){
      spawnCooldown = 120 + rng(120); // frames until next possible spawn
      spawnMini();
    }
    // small random tantrum spikes
    if(Math.random() < 0.001 * dt) mood += 0.02 * rng(10);
    // clamp
    mood = Math.min(1, mood);
    if(mood >= 1) triggerGameOver();
  } else if(state === STATE.MINIGAME){
    miniTimer -= dt;
    if(miniTimer <= 0){
      // failed mini-game -> increase mood
      mood += 0.12;
      activeMini = null;
      state = STATE.PLAY;
    }
    // mood still rises while mini active (but slower)
    mood += 0.0009 * dt;
    if(mood >= 1) triggerGameOver();
  }
  // update mood bar visual
  updateUI();
  // small score accumulation
  score += 0.01 * dt;
}

// spawn a random mini-game
const MINIS = ['SNACKS','DEFLECT','PETCAT','NOEYEROLL'];
function spawnMini(){
  const pick = MINIS[Math.floor(rng(MINIS.length))];
  activeMini = { type: pick, created: performance.now() };
  state = STATE.MINIGAME;
  // set timers/difficulty
  switch(pick){
    case 'SNACKS': miniTimer = 240; activeMini.foods = createFoods(4); break; // drag to girl
    case 'DEFLECT': miniTimer = 240; activeMini.bubbles = createBubbles(6); break; // tap bubbles
    case 'PETCAT': miniTimer = 160; activeMini.petClicks = 0; activeMini.targetClicks = 12; break; // tap fast
    case 'NOEYEROLL': miniTimer = 120; activeMini.progress = 0; activeMini.target = 1 + Math.floor(rng(3)); break;
  }
}

// helpers to create items
function createFoods(n){
  const list = [];
  for(let i=0;i<n;i++){
    list.push({
      x: 100 + rng(W-200),
      y: -50 - rng(200),
      vx: 0,
      vy: 1 + rng(1.8),
      w: 80 + rng(40),
      grabbed:false,
      type: ['cookie','cookie','pizza','bubbletea'][Math.floor(rng(4))]
    });
  }
  return list;
}
function createBubbles(n){
  const list=[];
  for(let i=0;i<n;i++){
    list.push({ x: 80 + rng(W-160), y: 80 + rng(H*0.4), r: 36 + rng(28), vx: (rng(2)-1)*0.5, vy: (rng(2)-1)*0.4 });
  }
  return list;
}

// pointer handlers during play/minigame
function handlePointerDown(p){
  if(state === STATE.MINIGAME && activeMini){
    if(activeMini.type === 'SNACKS'){
      // detect grab food
      for(let f of activeMini.foods){
        if(pointInRect(p.x,p.y,f.x-f.w/2,f.y-f.w/2,f.w,f.w)){
          f.grabbed = true;
          f.grabOffsetX = p.x - f.x;
          f.grabOffsetY = p.y - f.y;
        }
      }
    } else if(activeMini.type === 'DEFLECT'){
      // tap bubbles
      for(let i=activeMini.bubbles.length-1;i>=0;i--){
        const b = activeMini.bubbles[i];
        if(dist(p.x,p.y,b.x,b.y) < b.r*1.1){
          // pop
          activeMini.bubbles.splice(i,1);
          mood -= 0.04; if(mood<0) mood=0;
          if(activeMini.bubbles.length === 0) miniSuccess();
        }
      }
    } else if(activeMini.type === 'PETCAT'){
      activeMini.petClicks++;
      if(activeMini.petClicks >= activeMini.targetClicks) miniSuccess();
    } else if(activeMini.type === 'NOEYEROLL'){
      // quick taps increase progress
      activeMini.progress++;
      if(activeMini.progress >= activeMini.target) miniSuccess();
    }
  }
}

function handlePointerUp(p){ /* nothing for now */ }
function handlePointerMove(p){
  if(state === STATE.MINIGAME && activeMini){
    if(activeMini.type === 'SNACKS'){
      for(let f of activeMini.foods){
        if(f.grabbed){
          f.x = p.x - (f.grabOffsetX||0);
          f.y = p.y - (f.grabOffsetY||0);
        }
      }
    }
  }
}

// success for mini
function miniSuccess(){
  // reward: reduce mood
  const reduce = 0.15 + rng(0.06);
  mood = Math.max(0, mood - reduce);
  // small score bump
  score += 120;
  activeMini = null;
  state = STATE.PLAY;
}

// game over
function triggerGameOver(){
  state = STATE.GAMEOVER;
  overlay.style.display = 'flex';
  panel.querySelector('#title').innerText = 'THE EARTH... IS NOT OK';
  panel.querySelector('#subtitle').innerText = 'Huff & Puff went full tilt. The world took a nap.';
  panel.querySelector('#how').classList.add('hidden');
  panel.querySelector('#title').style.color = 'var(--bad)';
  panel.querySelector('#subtitle').style.color = '#333';
  startBtn.innerText = 'RETRY';
  overlay.style.pointerEvents = 'auto';
  playBtn.innerText = 'MENU';
  miniHud.classList.add('hidden');
  if(score > highScore) highScore = Math.floor(score);
}

// tiny utilities
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.sqrt(dx*dx+dy*dy); }
function pointInRect(px,py,x,y,w,h){ return px>=x && py>=y && px<=x+w && py<=y+h; }

// update UI mood bar
function updateUI(){
  const pct = clamp(mood,0,1);
  const w = (pct*100).toFixed(1) + '%';
  moodBar.style.width = w;
  // color shift
  if(pct < 0.4) moodBar.style.background = 'linear-gradient(90deg,var(--good),#FFD166)';
  else if(pct < 0.75) moodBar.style.background = 'linear-gradient(90deg,#FFD166,#F97316)';
  else moodBar.style.background = 'linear-gradient(90deg,var(--bad),#9B111E)';
  // show small anim in title panel when high mood
  const title = panel.querySelector('#title');
  if(title) title.style.transform = pct > 0.7 ? 'scale(1.02)' : 'scale(1)';
}

// render world
function render(){
  // background
  ctx.clearRect(0,0,W,H);
  // subtle cracked floor based on mood
  const floorY = H * 0.65;
  ctx.fillStyle = '#FFEFD5';
  ctx.fillRect(0,floorY,W,H-floorY);

  drawBackgroundScenery();

  // draw girl centered
  const girlX = W/2;
  const girlY = floorY - 220;
  drawGirl(girlX, girlY, 360, 0, mood);

  // if mini-game active, draw overlay UI for that mini-game
  if(state === STATE.MINIGAME && activeMini){
    drawMini(activeMini);
    // top-left mini description
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(40,60,420,110);
    ctx.fillStyle = '#333'; ctx.font = '26px sans-serif'; ctx.fillText(activeMini.type.replace(/([A-Z])/g,' $1').trim(), 60, 100);
    ctx.restore();
  }

  // small HUD: score & high score
  ctx.fillStyle = '#333';
  ctx.font = '28px sans-serif';
  ctx.fillText('Score: ' + Math.floor(score), 48, 48);
  ctx.fillText('Best: ' + highScore, 48, 84);

  // if gameover draw explosion
  if(state === STATE.GAMEOVER){
    drawGameOverEffect();
  }
}

function drawBackgroundScenery(){
  // simple room background: window, dresser, cat portrait
  const w = W, h = H;
  // window
  ctx.fillStyle='#8ED0FF';
  ctx.fillRect(w-320, 60, 240, 160);
  ctx.fillStyle='#FFF'; ctx.font='22px sans-serif'; ctx.fillText('Outside: sunny', w-310, 90);
  // dresser
  ctx.fillStyle='#F1C27D';
  ctx.fillRect(60, floorY-220, 220, 220);
  // framed cat
  ctx.fillStyle='#F3A683';
  ctx.fillRect(90, floorY-190, 80, 80);
  ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.fillText('Cat', 108, floorY-140);
}

function drawMini(m){
  ctx.save();
  // dim background
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.fillRect(0,0,W,H);
  // panel area
  const px = W*0.08, pw = W*0.84, py = H*0.15, ph = H*0.7;
  ctx.fillStyle = '#fff'; ctx.fillRect(px,py,pw,ph);
  // draw based on type
  ctx.translate(px,py);
  if(m.type === 'SNACKS'){
    // draw foods falling; draw girl on right as target
    for(let f of m.foods){
      f.y += f.vy;
      if(!f.grabbed) f.x += Math.sin((f.y/40)+f.x*0.0003)*0.6;
      // keep in bounds
      if(f.y > ph + 120) f.y = -40;
      ctx.fillStyle = '#E07A5F';
      ctx.beginPath(); ctx.ellipse(f.x, f.y, f.w/2, f.w/2, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.font = '20px sans-serif'; ctx.fillText(f.type[0].toUpperCase(), f.x-8, f.y+8);
    }
    // target girl box
    ctx.strokeStyle='#333'; ctx.strokeRect(pw-220, ph-260, 200, 250);
    ctx.fillStyle='#000'; ctx.font='18px sans-serif'; ctx.fillText('Huff', pw-160, ph-200);
    // if any food intersects target -> success
    for(let i=m.foods.length-1;i>=0;i--){
      const f = m.foods[i];
      const tx = pw-120, ty = ph-130;
      if(pointInRect(f.x, f.y, tx-80, ty-80, 150, 150) && (!f.grabbed || f.grabbed)){
        // accept
        m.foods.splice(i,1);
        mood = Math.max(0, mood - 0.08);
        if(m.foods.length === 0) miniSuccess();
      }
    }
  } else if(m.type === 'DEFLECT'){
    // animate bubbles slightly
    for(let b of m.bubbles){
      b.x += b.vx*1.4;
      b.y += b.vy*1.4;
      if(b.x < 40 || b.x > pw-40) b.vx *= -1;
      if(b.y < 40 || b.y > ph-40) b.vy *= -1;
      ctx.beginPath(); ctx.fillStyle = '#FFEDD5'; ctx.ellipse(b.x, b.y, b.r, b.r, 0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#333'; ctx.font='16px sans-serif'; ctx.fillText('!"', b.x-10, b.y+6);
    }
    ctx.fillStyle='#666'; ctx.font='15px sans-serif'; ctx.fillText('Tap the drama bubbles to pop them', 40, 40);
  } else if(m.type === 'PETCAT'){
    // cat image placeholder and tap meter
    ctx.fillStyle = '#FDE68A';
    ctx.fillRect(pw/2 - 160, ph/2 - 100, 320, 200);
    ctx.fillStyle='#333'; ctx.font='22px sans-serif'; ctx.fillText('Pet the cat!', pw/2-80, ph/2-20);
    // progress bar
    const prog = m.petClicks / m.targetClicks;
    ctx.fillStyle = '#E5E7EB'; ctx.fillRect(80, ph-120, pw-160, 24);
    ctx.fillStyle = '#34D399'; ctx.fillRect(80, ph-120, (pw-160)*prog, 24);
    ctx.fillStyle='#111'; ctx.font='18px sans-serif'; ctx.fillText(m.petClicks + ' / ' + m.targetClicks, pw/2-28, ph-116);
  } else if(m.type === 'NOEYEROLL'){
    ctx.fillStyle='#FFF1F2'; ctx.fillRect(60,120,pw-120,ph-240);
    ctx.fillStyle='#222'; ctx.font='22px sans-serif'; ctx.fillText('Stop the eye-rolls!', 80, 160);
    // progress dots
    for(let i=0;i<m.target;i++){
      ctx.beginPath(); ctx.fillStyle = (i < m.progress ? '#34D399' : '#E5E7EB');
      ctx.ellipse(120 + i*64, ph/2 - 40, 24, 24, 0,0,Math.PI*2); ctx.fill();
    }
    ctx.fillStyle='#555'; ctx.font='16px sans-serif'; ctx.fillText('Tap quickly to break the roll', 80, ph/2 + 40);
  }
  ctx.restore();
}

// small explosion effect
function drawGameOverEffect(){
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = '#FF6262';
  ctx.beginPath();
  ctx.ellipse(W/2, H/2, W*0.4*mood, H*0.25*mood, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#FFF';
  ctx.font = '48px sans-serif';
  ctx.fillText('BOOM', W/2 - 70, H/2 + 10);
  ctx.restore();
}

// power-up UI
function renderPowerUps(){
  powerUpList.innerHTML = '';
  const k = Object.keys(powerUps);
  for(let key of k){
    const e = document.createElement('div');
    e.className = 'power';
    e.innerHTML = `<div style="font-weight:700">${key.toUpperCase()}</div><div class="small">x ${powerUps[key]}</div>`;
    powerUpList.appendChild(e);
  }
}

/* small helper: packaging & usage instructions shown in console */
console.log(`
Huff & Puff - instructions:
- Save this file as index.html
- Open in a modern browser (desktop or mobile)
- To add your artwork replace drawGirl and drawBackgroundScenery with image draws
- To package as a PWA or native app:
  * For web hosting: upload to GitHub Pages, Netlify, or Vercel
  * For native: use Capacitor (npm i -g @capacitor/cli)
    - npm init (for a project), copy this file to www/index.html
    - npx cap init com.example.huffpuff "HuffPuff"
    - npx cap add android
    - npx cap open android
`);

</script>
</body>
</html>
